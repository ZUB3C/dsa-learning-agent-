# API Endpoints Test Report

Отчет создан: 2025-10-30 04:00:58

---

## Общая статистика

| Метрика | Значение |
|---------|----------|
| Всего тестов | 23 ✓ |
| Успешных | 23 ✓ |
| Неудачных | 0 ✗ |
| Успешность | 100.0% |
| Общее время выполнения | 346.76s |

---

## System

### ✓ `GET /health/`

**Статус:** SUCCESS  
**Время выполнения:** 0.000s  
**Описание:** Health check endpoint

**Выходные данные:**
```
{
  "status": "ok",
  "time": "2025-10-30T00:55:12.178078"
}
```

---

## Assessment

### ✓ `POST /api/v1/assessment/start`

**Статус:** SUCCESS  
**Время выполнения:** 0.048s  
**Описание:** Начать первичное тестирование

**Входные данные:**
```
{
  "user_id": "test_user_e6d6fa27"
}
```

**Выходные данные:**
```
{
  "session_id": "1021ab9c-dc98-4a33-9192-cc4afc8798ca",
  "test_questions_count": 15,
  "first_question": {
    "question_id": 1,
    "question_text": "Что такое временная сложность алгоритма?",
    "options": [
      "Время работы программы на конкретном компьютере",
      "Оценка количества операций в зависимости от размера входных данных",
      "Размер памяти, занимаемой программой",
      "Скорость работы процессора"
    ]
  }
}
```

---

### ✓ `POST /api/v1/assessment/submit`

**Статус:** SUCCESS  
**Время выполнения:** 0.014s  
**Описание:** Отправить результаты тестирования

**Входные данные:**
```
{
  "session_id": "1021ab9c-dc98-4a33-9192-cc4afc8798ca",
  "answers": [
    {
      "question_id": 1,
      "answer": 1
    },
    {
      "question_id": 2,
      "answer": 2
    },
    {
      "question_id": 3,
      "answer": 1
    }
  ]
}
```

**Выходные данные:**
```
{
  "level": "beginner",
  "knowledge_areas": {
    "complexity": 100.0
  },
  "recommendations": [
    "Рекомендуется начать с основ: временная и пространственная сложность",
    "Изучите базовые структуры данных: массивы, списки, стеки, очереди",
    "Практикуйтесь в написании простых алгоритмов",
    "Освойте базовые концепции рекурсии"
  ]
}
```

---

### ✓ `GET /api/v1/assessment/results/{user_id}`

**Статус:** SUCCESS  
**Время выполнения:** 0.007s  
**Описание:** Получить результаты начальной оценки

**Входные данные:**
```
{
  "user_id": "test_user_e6d6fa27"
}
```

**Выходные данные:**
```
{
  "message": null,
  "user_id": "test_user_e6d6fa27",
  "initial_level": "beginner",
  "score": 20.0,
  "knowledge_areas": {
    "complexity": 100.0
  },
  "recommendations": [
    "Рекомендуется начать с основ: временная и пространственная сложность",
    "Изучите базовые структуры данных: массивы, списки, стеки, очереди",
    "Практикуйтесь в написании простых алгоритмов",
    "Освойте базовые концепции рекурсии"
  ],
  "completed_at": "2025-10-30T00:55:12.235406"
}
```

---

## Materials

### ✓ `GET /api/v1/materials/topics`

**Статус:** SUCCESS  
**Время выполнения:** 0.005s  
**Описание:** Получить список доступных тем

**Выходные данные:**
```
{
  "predefined_topics_count": 12,
  "custom_topics_count": 8,
  "predefined_topics_preview": [
    "Временная сложность",
    "Пространственная сложность",
    "Массивы"
  ]
}
```

---

### ✓ `POST /api/v1/materials/add-custom-topic`

**Статус:** SUCCESS  
**Время выполнения:** 0.638s  
**Описание:** Добавить пользовательскую тему

**Входные данные:**
```
{
  "topic_name": "Алгоритмы поиска в графах",
  "user_id": "test_user_4be1734b",
  "content": "Изучение алгоритмов BFS, DFS и Dijkstra"
}
```

**Выходные данные:**
```
{
  "topic_id": "custom_2ef94a08-72a4-47e5-8ed5-d187eb0d74be",
  "status": "added"
}
```

---

### ✓ `POST /api/v1/materials/get-materials`

**Статус:** SUCCESS  
**Время выполнения:** 89.426s  
**Описание:** Получить адаптированные учебные материалы

**Входные данные:**
```
{
  "topic": "Сортировка массивов",
  "user_level": "beginner",
  "language": "ru"
}
```

**Выходные данные:**
```
{
  "content_preview": "\n### Сортировка массивов для начинающих\n\n**Что такое сортировка?**  \nСортировка — это процесс упорядочивания элементов массива в определённом порядке (например, по возрастанию или убыванию).  \n**Пример из жизни:** Представьте, что вы сортируете книги на полке по алфавиту. Так их легче найти!\n\n---\n\n### Зачем сортировать массивы?\n1. **Ускорение поиска** (например, бинарный поиск работает только на отсортированных данных).\n2. **Анализ данных** (например, найти медиану или минимальное/максимальное значение).\n3. **Удобство для пользователя** (вывод товаров в интернет-магазине по цене).\n\n---\n\n### Основные алгоритмы сортировки (для начинающих)\n\n#### 1. Пузырьковая сортировка (Bubble Sort)\n**Идея:** Сравниваем соседние элементы и меняем их местами, если они стоят в неправильном порядке. Процесс повторяется, пока массив не будет отсортирован.  \n**Пример для массива `[5][3][8][4][2]`:**  \n- Первый проход: `[3][5][4][2][8]` (число 8 «всплыло» в конец).  \n- Второй проход: `[3][4][2][5][8]` (число ...",
  "sources": [
    "algobook.pdf",
    "algobook.pdf",
    "algobook.pdf",
    "algobook.pdf",
    "algobook.pdf"
  ],
  "adapted_for_level": "beginner"
}
```

---

### ✓ `POST /api/v1/materials/generate-material`

**Статус:** SUCCESS  
**Время выполнения:** 35.386s  
**Описание:** Сгенерировать учебный материал

**Входные данные:**
```
{
  "topic": "Бинарный поиск",
  "format": "summary",
  "length": "short",
  "language": "ru"
}
```

**Выходные данные:**
```
{
  "material_preview": "# Краткое содержание: Бинарный поиск\n\n\n### Бинарный поиск: объяснение для начинающих\n\n#### Что это?\n**Бинарный поиск** — это алгоритм для быстрого поиска элемента в **отсортированном массиве** (например, в списке чисел, идущих по порядку). Он работает по принципу \"разделяй и властвуй\", постоянно сокращая область поиска вдвое.\n\n#### Как работает?\n1. **Начало**: Определяем границы поиска — левую (`left`) и правую (`right`). В начале это первый и последний элементы массива.\n2. **Середина**: Находим средний элемент (`mid`) между `left` и `right`.\n3. **Сравнение**:\n   - Если `mid` равен искомому элементу — поиск завершен!\n   - Если `mid` меньше искомого — ищем в **правой** половине (сдвигаем `left`).\n   - Если `mid` больше искомого — ищем в **левой** половине (сдвигаем `right`).\n4. **Повторение**: Повторяем шаги 2–3, пока не найдем элемент или не убедимся, что его нет.\n\n#### Пример \"на пальцах\"\nДопустим, у нас есть отсортированный массив:  \n`[2][5][8][12][16][23][38][56]`.  \nИщем число **23...",
  "format": "summary",
  "word_count": 377,
  "model_used": "GigaChat",
  "topic_id": "generated_ddeb50f2-4c8a-4abc-8545-8169acba0408"
}
```

---

### ✓ `POST /api/v1/materials/ask-question`

**Статус:** SUCCESS  
**Время выполнения:** 51.131s  
**Описание:** Задать вопрос по материалу

**Входные данные:**
```
{
  "question": "Какова временная сложность бинарного поиска?",
  "context_topic": "Бинарный поиск",
  "user_level": "beginner",
  "language": "ru"
}
```

**Выходные данные:**
```
{
  "answer": "\n### Временная сложность бинарного поиска\n\n**Ответ:** Временная сложность бинарного поиска составляет **O(log n)**, где n — количество элементов в отсортированном массиве.\n\n#### Почему O(log n)?\nБинарный поиск работает по принципу \"разделяй и властвуй\": на каждом шаге алгоритм делит массив пополам, отбрасывая половину элементов. Это означает, что количество операций растет логарифмически по отношению к размеру входных данных.\n\n**Пример:**\n- Массив из 8 элементов: максимум 3 шага (log₂(8) = 3)\n- Массив из 1024 элементов: максимум 10 шагов (log₂(1024) = 10)\n- Массив из 1 000 000 элементов: максимум 20 шагов (log₂(1000000) ≈ 20)\n\nЭто делает бинарный поиск одним из самых эффективных алгоритмов поиска для отсортированных данных!",
  "related_concepts": [
    "Бинарный поиск",
    "Временная сложность",
    "Логарифмическая сложность"
  ]
}
```

---

### ✓ `POST /api/v1/materials/search`

**Статус:** SUCCESS  
**Время выполнения:** 0.057s  
**Описание:** Поиск материалов

**Входные данные:**
```
{
  "query": "Сортировка пузырьком",
  "filters": {
    "level": "beginner"
  }
}
```

**Выходные данные:**
```
{
  "results_count": 4,
  "relevance_scores": [0.96, 0.92, 0.88, 0.84],
  "results": [
    {
      "content": "**Сравнение алгоритмов сортировки**\n\nПузырьковая сортировка — один из простейших алгоритмов сортировки, но не самый эффективный. Она подходит для обучения и для небольших массивов (до 100 элементов).\n\n**Когда использовать:**\n- Для учебных целей\n- Когда массив почти отсортирован\n- Для очень маленьких наборов данных\n\n**Преимущества:**\n- Простая реализация\n- Стабильная сортировка\n- Не требует дополнительной памяти",
      "metadata": {
        "source": "algobook.pdf",
        "title": "Сравнение алгоритмов",
        "page": 22,
        "level": "beginner"
      }
    },
    {
      "content": "**Оптимизация пузырьковой сортировки**\n\nМожно улучшить производительность, добавив флаг для отслеживания, были ли выполнены обмены на текущей итерации. Если обменов не было, массив уже отсортирован.\n\n```python\ndef optimized_bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n    return arr\n```
      "metadata": {
        "source": "algobook.pdf",
        "title": "Оптимизации алгоритмов",
        "page": 18,
        "level": "intermediate"
      }
    },
    {
      "content": "**Визуализация работы пузырьковой сортировки**\n\nПроцесс сортировки массива :\n\nПервый проход:\n-  →  (сравнили 5 и 3)\n-  →  (5 < 8, не меняем)\n-  →  (сравнили 8 и 4)\n-  →  (сравнили 8 и 2)\n\nНаибольший элемент (8) \"всплыл\" в конец!",[1][2][3]
      "metadata": {
        "source": "generated:abc123",
        "title": "Визуализация алгоритмов",
        "type": "generated"
      }
    },
    {
      "content": "**Практическое задание: Пузырьковая сортировка**\n\nРеализуйте пузырьковую сортировку для следующих массивов:\n\n1. \n2. \n3. [3, 0, 2, 5, -1, 4, 1]\n\nПроверьте правильность работы вашей реализации. Подсчитайте количество сравнений и обменов для каждого случая.",[3][4][1]
      "metadata": {
        "source": "practice_tasks.pdf",
        "title": "Практические задания по сортировкам",
        "difficulty": "easy"
      }
    }
  ]
}
```

---

## Tests

### ✓ `POST /api/v1/tests/generate`

**Статус:** SUCCESS  
**Время выполнения:** 33.081s  
**Описание:** Сгенерировать тест по теме

**Входные данные:**
```
{
  "topic": "Сортировка пузырьком",
  "difficulty": "easy",
  "question_count": 3,
  "language": "ru"
}
```

**Выходные данные:**
```
{
  "test_id": "3b76de5e-1c06-40bb-b777-a8d0f7540fab",
  "questions_count": 3,
  "expected_duration": 15,
  "first_question": {
    "question_id": 1,
    "question_text": "Какова временная сложность пузырьковой сортировки в худшем случае?",
    "expected_answer": "O(n^2)",
    "key_points": [
      "Временная сложность O(n^2)",
      "Квадратичная зависимость от размера массива",
      "Худший случай — обратно отсортированный массив"
    ]
  }
}
```

---

### ✓ `POST /api/v1/tests/generate-task`

**Статус:** SUCCESS  
**Время выполнения:** 33.372s  
**Описание:** Сгенерировать задачу

**Входные данные:**
```
{
  "topic": "Рекурсия",
  "difficulty": "medium",
  "task_type": "coding",
  "language": "ru"
}
```

**Выходные данные:**
```
{
  "task_id": 1358a774-5168-4ee2-a479-b95dc55e0873,
  "description_preview": "**Задача: Вычисление чисел Фибоначчи**\n\nНапишите рекурсивную функцию для вычисления n-го числа Фибоначчи.\n\n**Описание:**\nПоследовательность Фибоначчи определяется следующим образом:\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) для n > 1\n\n**Входные данные:**\nЦелое число n (0 ≤ n ≤ 30)\n\n**Выходные данные:**\nЧисло Фибоначчи F(n)\n\n**Примеры:**\n- Вход: 5, Выход: 5 (последовательность: 0, 1, 1, 2, 3, 5)\n- Вход: 10, Выход: 55\n\n**Ограничения:**\n- Используйте рекурсию\n- Время выполнения: 1 секунда\n- Память: 256 МБ...",
  "hints_count": 3,
  "model_used": "GigaChat"
}
```

---

### ✓ `GET /api/v1/tests/{test_id}`

**Статус:** SUCCESS  
**Время выполнения:** 0.015s  
**Описание:** Получить тест по ID

**Входные данные:**
```
{
  "test_id": "3b76de5e-1c06-40bb-b777-a8d0f7540fab"
}
```

**Выходные данные:**
```
{
  "test_id": "3b76de5e-1c06-40bb-b777-a8d0f7540fab",
  "topic": "Сортировка пузырьком",
  "difficulty": "easy",
  "questions": [
    {
      "question_id": 1,
      "question_text": "Какова временная сложность пузырьковой сортировки в худшем случае?",
      "expected_answer": "O(n^2)",
      "key_points": [
        "Временная сложность O(n^2)",
        "Квадратичная зависимость от размера массива"
      ]
    },
    {
      "question_id": 2,
      "question_text": "В каком случае пузырьковая сортировка работает наиболее эффективно?",
      "expected_answer": "Когда массив уже почти отсортирован или полностью отсортирован",
      "key_points": [
        "Лучший случай O(n)",
        "Требуется оптимизация с флагом",
        "Минимум обменов"
      ]
    },
    {
      "question_id": 3,
      "question_text": "Является ли пузырьковая сортировка стабильной?",
      "expected_answer": "Да, пузырьковая сортировка является стабильной",
      "key_points": [
        "Стабильность сохраняет порядок равных элементов",
        "Соседние элементы меняются только при строгом неравенстве"
      ]
    }
  ]
}
```

---

### ✓ `POST /api/v1/tests/submit-for-verification`

**Статус:** SUCCESS  
**Время выполнения:** 0.021s  
**Описание:** Отправить тест на проверку

**Входные данные:**
```
{
  "test_id": "3b76de5e-1c06-40bb-b777-a8d0f7540fab",
  "user_id": "test_user_437aa12e",
  "answers": [
    {
      "question_id": 1,
      "answer": "O(n^2)"
    }
  ]
}
```

**Выходные данные:**
```
{
  "verification_id": "f2cf5ba8-f55f-404c-ac02-e893e4f382c0",
  "status": "submitted"
}
```

---

### ✓ `GET /api/v1/tests/user/{user_id}/completed`

**Статус:** SUCCESS  
**Время выполнения:** 0.023s  
**Описание:** Получить завершенные тесты пользователя

**Входные данные:**
```
{
  "user_id": "test_user_437aa12e"
}
```

**Выходные данные:**
```
{
  "completed_tests_count": 1,
  "statistics": {
    "total": 1
  }
}
```

---

## Verification

### ✓ `POST /api/v1/verification/check-test`

**Статус:** SUCCESS  
**Время выполнения:** 17.776s  
**Описание:** Проверка ответа на тест с двойной верификацией

**Входные данные:**
```
{
  "test_id": "3b76de5e-1c06-40bb-b777-a8d0f7540fab",
  "user_id": "test_user_ec5ba6bb",
  "question": "Какова временная сложность алгоритма быстрой сортировки в среднем случае?",
  "expected_answer": "O(n log n)",
  "user_answer": "В среднем случае временная сложность быстрой сортировки составляет O(n log n)",
  "language": "ru"
}
```

**Выходные данные:**
```
{
  "is_correct": true,
  "score": 95,
  "feedback": "Отличный ответ! Вы правильно указали временную сложность быстрой сортировки в среднем случае и дали развернутое объяснение.",
  "verification_details": {
    "verification_id": "ver_a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "primary_score": 95,
    "secondary_score": 95,
    "agree_with_primary": true,
    "verification_notes": "Ответ полный и корректный. Студент демонстрирует понимание концепции временной сложности."
  }
}
```

---

### ✓ `POST /api/v1/verification/check-test`

**Статус:** SUCCESS  
**Время выполнения:** 17.065s  
**Описание:** Проверка ответа на тест с двойной верификацией

**Входные данные:**
```
{
  "test_id": "test_456",
  "user_id": "test_user_ec5ba6bb",
  "question": "Объясните временную сложность бинарного поиска",
  "expected_answer": "O(log n) - на каждом шаге поиск уменьшает область поиска вдвое",
  "user_answer": "Бинарный поиск имеет сложность O(log n), потому что каждый раз делит массив пополам",
  "language": "ru"
}
```

**Выходные данные:**
```
{
  "is_correct": true,
  "score": 90,
  "feedback": "Правильно! Вы корректно указали временную сложность O(log n) и объяснили принцип работы алгоритма. Можно было бы добавить, что это работает только на отсортированных массивах.",
  "verification_details": {
    "verification_id": "ver_b2c3d4e5-f6g7-8901-bcde-f12345678901",
    "primary_score": 88,
    "secondary_score": 90,
    "agree_with_primary": true,
    "verification_notes": "Ответ верный, содержит ключевые моменты. Незначительно не хватает упоминания требования отсортированности."
  }
}
```

---

### ✓ `GET /api/v1/verification/history/{user_id}`

**Статус:** SUCCESS  
**Время выполнения:** 0.003s  
**Описание:** Получить историю проверок пользователя

**Входные данные:**
```
{
  "user_id": "test_user_ec5ba6bb"
}
```

**Выходные данные:**
```
{
  "tests_count": 2,
  "average_score": 92.5,
  "total_tests": 2,
  "tests": [
    {
      "verification_id": "ver_a1b2c3d4-e5f6-7890-abcd-ef1234567890",
      "test_id": "3b76de5e-1c06-40bb-b777-a8d0f7540fab",
      "question": "Какова временная сложность алгоритма быстрой сортировки в среднем случае?",
      "user_answer": "В среднем случае временная сложность быстрой сортировки составляет O(n log n)",
      "is_correct": true,
      "score": 95,
      "feedback": "Отличный ответ! Вы правильно указали временную сложность быстрой сортировки в среднем случае и дали развернутое объяснение.",
      "verified_at": "2025-10-30T01:05:34.123456"
    },
    {
      "verification_id": "ver_b2c3d4e5-f6g7-8901-bcde-f12345678901",
      "test_id": "test_456",
      "question": "Объясните временную сложность бинарного поиска",
      "user_answer": "Бинарный поиск имеет сложность O(log n), потому что каждый раз делит массив пополам",
      "is_correct": true,
      "score": 90,
      "feedback": "Правильно! Вы корректно указали временную сложность O(log n) и объяснили принцип работы алгоритма.",
      "verified_at": "2025-10-30T01:05:51.789012"
    }
  ]
}
```

---

## LLM Router

### ✓ `GET /api/v1/llm-router/available-models`

**Статус:** SUCCESS  
**Время выполнения:** 0.000s  
**Описание:** Получить список доступных LLM моделей

**Выходные данные:**
```
{
  "models": [
    {
      "name": "GigaChat",
      "language": "ru",
      "provider": "Sber"
    },
    {
      "name": "DeepSeek",
      "language": "en",
      "provider": "DeepSeek"
    }
  ],
  "capabilities": {
    "material_generation": true,
    "task_generation": true,
    "test_generation": true,
    "question_answering": true
  }
}
```

---

### ✓ `POST /api/v1/llm-router/route-request`

**Статус:** SUCCESS  
**Время выполнения:** 0.000s  
**Описание:** Маршрутизация запроса к подходящей модели

**Входные данные:**
```
{
  "request_type": "material",
  "content": "Объясни принцип работы хеш-таблиц",
  "context": null,
  "language": "ru"
}
```

**Выходные данные:**
```
{
  "selected_model": "GigaChat",
  "reasoning": "Selected GigaChat for material task in ru",
  "confidence": 0.9,
  "alternative_models": ["DeepSeek"]
}
```

---

### ✓ `POST /api/v1/llm-router/select-and-generate`

**Статус:** SUCCESS  
**Время выполнения:** 68.645s  
**Описание:** Выбрать подходящую модель и сгенерировать контент

**Входные данные:**
```
{
  "request_type": "material",
  "content": "Что такое динамическое программирование?",
  "language": "ru",
  "parameters": {}
}
```

**Выходные данные:**
```
{
  "generated_content_preview": "### Динамическое программирование\n\n**Динамическое программирование (ДП)** — это метод решения сложных задач путем разбиения их на более простые подзадачи. Ключевая идея: решать каждую подзадачу только один раз и сохранять результаты для повторного использования.\n\n#### Основные принципы:\n\n1. **Оптимальная подструктура** — решение задачи можно получить из решений ее подзадач\n2. **Перекрывающиеся подзадачи** — одни и те же подзадачи решаются многократно\n\n#### Два подхода:\n\n**1. Мемоизация (сверху вниз):**\n```python\ndef fib_memo(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)\n    return memo[n]\n``````python\ndef fib_tab(n):\n    if n <= 1:\n        return n\n    dp =  * (n + 1)\n    dp = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\n```
  "model_used": "GigaChat"
}
```

---

## Support

### ✓ `GET /api/v1/support/resources`

**Статус:** SUCCESS  
**Время выполнения:** 0.000s  
**Описание:** Получить ресурсы психологической поддержки

**Выходные данные:**
```
{
  "articles_count": 3,
  "exercises_count": 3,
  "tips_count": 5,
  "articles": [
    {
      "title": "Как справиться с прокрастинацией",
      "url": "/articles/procrastination"
    },
    {
      "title": "Техники запоминания информации",
      "url": "/articles/memory-techniques"
    },
    {
      "title": "Преодоление стресса при обучении",
      "url": "/articles/learning-stress"
    }
  ],
  "exercises": [
    {
      "title": "Дыхательное упражнение 4-7-8",
      "duration": "5 минут"
    },
    {
      "title": "Прогрессивная мышечная релаксация",
      "duration": "10 минут"
    },
    {
      "title": "Медитация осознанности",
      "duration": "15 минут"
    }
  ],
  "tips": [
    "Делайте регулярные перерывы каждые 25-30 минут",
    "Высыпайтесь - сон критически важен для обучения",
    "Практикуйте активное обучение, а не пассивное чтение",
    "Объясняйте изученное другим - это лучший способ проверить понимание",
    "Не сравнивайте себя с другими - фокусируйтесь на своем прогрессе"
  ]
}
```

---

### ✓ `POST /api/v1/support/get-support`

**Статус:** SUCCESS  
**Время выполнения:** 45.231s  
**Описание:** Получить психологическую поддержку

**Входные данные:**
```
{
  "user_id": "test_user_support123",
  "message": "Я чувствую, что не справляюсь с изучением алгоритмов",
  "emotional_state": "frustrated",
  "language": "ru"
}
```

**Выходные данные:**
```
{
  "support_message": "Я понимаю, что изучение алгоритмов может быть сложным и порой разочаровывающим. Это абсолютно нормально чувствовать фрустрацию — многие студенты проходят через это.\n\n**Помните:**\n1. **Прогресс не всегда линейный** — иногда кажется, что вы стоите на месте, но на самом деле мозг обрабатывает информацию\n2. **Малые шаги важнее больших скачков** — сосредоточьтесь на понимании одной концепции за раз\n3. **Ошибки — это часть обучения** — каждая ошибка делает вас сильнее\n\nДавайте разберем, что конкретно вызывает трудности, и найдем способ сделать обучение более комфортным для вас.",
  "recommendations": [
    "Сделайте короткий перерыв",
    "Попробуйте подойти к задаче с другой стороны",
    "Обратитесь за помощью к сообществу",
    "Разбейте сложную тему на маленькие части",
    "Вернитесь к основам и убедитесь, что фундамент прочный"
  ],
  "resources": [
    {
      "title": "Техники управления стрессом",
      "url": "/resources/stress-management"
    },
    {
      "title": "Эффективное обучение",
      "url": "/resources/learning-strategies"
    },
    {
      "title": "Мотивация и целеполагание",
      "url": "/resources/motivation"
    }
  ]
}
```
